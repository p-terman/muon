function LoadAndBuildLUXSim(data_dir, output_dir, options)
% LoadAndBuildLUXSim(data_dir, output_dir, options)
%
% Read in LUXSim .bin files and record stats for whole event. Positions / energy depositions / 
% primary particle information is recorded for every event. Fields are either 1xN or MxN, where 
% N is the number of events where >0 energy was deposited in any sensitive region in the MC and 
% M is the number of sensitive regions which had a hit in them for any of the files analyzed.
% 
% Note that, for multiple .mat files generated by this function, the ordering of the sensitive
% regions (and even the value of M) can change from one file to the next. When loading multiple 
% .mat files, one must always normalize by using the sim_info structure and finding the 
% appropriate component name or ID.
%
% LoadAndBuildLUXSim creates sim_data variable, with the following fields:
%  .num_evts_emitted
%  .primary_E
%  .primary_position
%  .primary_direction
%  .E_dep
%  .E_dep_NR
%  .E_dep_ER
%  .r_NR
%  .x_NR
%  .y_NR
%  .z_NR
%  .t_NR
%  .r_ER
%  .x_ER
%  .y_ER
%  .z_ER
%  .t_ER
%  .r
%  .x
%  .y
%  .z
%  .t
%  .sigma_r_NR
%  .sigma_x_NR
%  .sigma_y_NR
%  .sigma_z_NR
%  .sigma_t_NR
%  .sigma_r_ER
%  .sigma_x_ER
%  .sigma_y_ER
%  .sigma_z_ER
%  .sigma_t_ER
%  .sigma_r
%  .sigma_x
%  .sigma_y
%  .sigma_z
%  .sigma_t
%
% Also creates sim_info varible, with the following fields:
%  .component_IDs
%  .component_names
%  .time_window_ns
%
% Saves file in [output_dir]/[bin file name]_lab.mat)
%
% Required inputs:
%  data_dir - directory containing .bin files
%
% Optional inputs:
%  output_dir - directory to save output file. [Default: data_dir]
%  options - structure with the following recognized fields:
%   .ER_only - slims down file sizes for gamma-only studies. When set to 1,
%    only records the following fields in sim_data:
%     .num_evts_emitted
%     .primary_E
%     .primary_position
%     .primary_direction
%     .E_dep
%     .r
%     .x
%     .y
%     .z
%     .t
%     .sigma_r
%     .sigma_x
%     .sigma_y
%     .sigma_z
%     .sigma_t
%    [Default: 0]
%   .overwrite - overwrites existing LoadAndBuild files. [Default: 0]
%   .time_window_ns - set max time window for steps to be included in
%     event. Note that events beyond the time window are discarded (NOT
%     counted as a separate event). [Default: Inf]
%   .save_primary_names - set to 0 to not save primary names (these take up a lot of 
%	 space). [Default: 1]
%   .use_mex - set to 0 to use Matlab functions only (i.e. if the MEX
%     function just isn't working). [Default: 1]
%
% 2012-03-27 DCM - moved from Brown code SVN to LUXSim SVN
% 2012-05-15 DCM - changes to accommodate thermal electron record level 
%                  recording
% 2012-11-28 DCM - changed to have 1:1 file mapping with .bin files.
%                  Removed unnecessary inputs / options. Removed built-in
%                  settings.
% 2013-02-05 DCM - switched over to using LUXSimMatlabReader_LoadFile
% 2014-04-04 SF - fixed the LoadWithoutMex function by copying that found
%                 in LUXSimMatlabReader.m and changing a few variables.
%                 . Added primary_time variable to output. 
%                 . Added primary_name variable to output. 
%                 . Also added in the option to save primary names.
%                 . Left the variable save_hits_names in the program but 
%                 it should never be used for this loader (set to false).
%                 . Changed file saving so that random number appended to
%                 bin file is not kept. Instead append a file number
%                 counter. option commented out to old scheme.
% 2015-08-20 KK  - Added the step process name to the processing



%% Input checking

if nargin == 0
    disp('data_dir must be specified.');
    return
end

if nargin == 1 || isempty(output_dir)
    output_dir = data_dir;
end

if nargin < 3
    options = [];
end

%% Process options structure

if ~isempty(options)
    field_names = fieldnames(options);
    for ii=1:length(field_names)
        eval([field_names{ii} ' = options.' field_names{ii} ';']);
    end
end

if ~exist('ER_only','var')
    ER_only = 0;
end

if ~exist('overwrite','var')
    overwrite = 0;
end

if ~exist('time_window_ns','var')
    time_window_ns = Inf;
end

if ~exist('save_hit_names','var')   % legacy variable, should always be false
    save_hit_names = false;
end

if ~exist('save_primary_names','var')
    save_primary_names = true;
end

if ~exist('use_mex','var')
    use_mex = 1;
end


%% Create output directory if it doesn't already exist
if ~exist(output_dir,'dir')
    fprintf('Creating output directory %s\n', output_dir);
    mkdir(output_dir);
end


%% Get files to load

function_start_time = clock;
function_end_time = function_start_time; % somehow function sometimes errors if this is not defined here

files = dir([data_dir filesep '*.bin']);
files_to_load = {files.name};

% Find all files with corresponding LoadAndBuild files and remove these
% from the to-do list
if ~overwrite
    mat_files = dir([data_dir filesep '*_lab.mat']);
    mat_files = {mat_files.name};
    for ii_m=1:length(mat_files)
        name = mat_files{ii_m}(1:end-8);
        match_ind = find(strcmp(files_to_load,[name '.bin']),1);
        if ~isempty(match_ind)
            files_to_load(match_ind) = [];
        end
    end
end

%% Initialize

num_evts = 0;


%% Do analysis

run_start = clock;


for ii_file=1:length(files_to_load)

    file_start_time = clock;
    
    % initialize data structures
    clear sim_data sim_info
    [sim_data,sim_info] = InitializeDataStructures(ER_only,time_window_ns);
    
    % load file
    fprintf('\nLoading file %s (%d/%d)... ',files_to_load{ii_file},ii_file,length(files_to_load));
    t = clock;
    if use_mex
        if exist('LUXSimMatlabReader_LoadFile','file');
            try
                [record,info] = LUXSimMatlabReader_LoadFile([data_dir filesep files_to_load{ii_file}]);
            catch
                fprintf('Warning: could not execute MEX code LUXSimMatlabReader_LoadFile.\nUsing non-MEX code...\n');
                use_mex = 0;
            end
        else
            fprintf('Warning: could not find LUXSimMatlabReader_LoadFile.\nUsing non-MEX code...\n');
            use_mex = 0;
        end
    end
    
    if ~use_mex
        [record,info] = LoadWithoutMEX([data_dir filesep files_to_load{ii_file}],save_hit_names,save_primary_names);
    end
    file_end_time = clock;
    fprintf('100%% loaded (%d evts / %d steps in %3.2f s)\n', ...
        length(record.total_energy_deposition), length(record.energy_deposition), ...
        etime(file_end_time, file_start_time));
    
    % check to see if file is OK
    if ~exist('info','var') || ~exist('record','var') || isempty(record) || isempty(info)
        fprintf('Warning: file %s is badly formed. Continuing...\n', files_to_load{ii_file});
        continue
    end
    
    % figure out whether to save names
%   if ~save_primary_names
%       record = rmfield(record,'primary_name');
%	end
%	if ~save_hit_names
%		record = rmfield(record,'particle_name');
%       record = rmfield(record,'creator_process_name');
%       record = rmfield(record,'step_process_name');
%	end
    
    tic;
    
    % %%%%% Assign & cut out events with 0 total energy deposition %%%%% %
    
    event_cut = record.total_energy_deposition > 0;
    
    record.record_level = record.record_level(event_cut);
    record.opticalphoton_record_level = record.opticalphoton_record_level(event_cut);
    record.volume_id = record.volume_id(event_cut);
    record.event_num = record.event_num(event_cut);
    record.total_energy_deposition = record.total_energy_deposition(event_cut);
    record.num_opticalphotons = record.num_opticalphotons(event_cut);
    record.hits_size = record.hits_size(event_cut);
    record.record_hits_ind = record.record_hits_ind(event_cut);

    if save_primary_names
        record.primary_name = record.primary_name(event_cut);
    end
    record.primary_time = record.primary_time(event_cut);
    record.primary_energy = record.primary_energy(event_cut);
    record.primary_position = record.primary_position(event_cut,:);
    record.primary_direction = record.primary_direction(event_cut,:);
    record.primary_event_num = record.primary_event_num(event_cut);
    
    hits_ind_to_save = zeros(1,length(record.event_num));
    ctr = 1;
    for ii=1:length(record.record_hits_ind)
        hits_ind_to_save(ctr+(0:(record.hits_size(ii)-1))) = ...
            record.record_hits_ind(ii)+(0:(record.hits_size(ii)-1));
        ctr = ctr + record.hits_size(ii);
    end
    hits_ind_to_save = hits_ind_to_save(hits_ind_to_save > 0);
    
    if save_hit_names
        record.particle_name = record.particle_name(hits_ind_to_save);
        record.creator_process_name = record.creator_process_name(hits_ind_to_save);
        record.step_process_name = record.step_process_name(hits_ind_to_save);
    end
    record.step_num = record.step_num(hits_ind_to_save);
    record.particle_id = record.particle_id(hits_ind_to_save);
    record.track_id = record.track_id(hits_ind_to_save);
    record.parent_id = record.parent_id(hits_ind_to_save);
    record.particle_energy = record.particle_energy(hits_ind_to_save);
    record.particle_direction = record.particle_direction(hits_ind_to_save,:);
    record.energy_deposition = record.energy_deposition(hits_ind_to_save);
    record.position = record.position(hits_ind_to_save,:);
    record.step_time = record.step_time(hits_ind_to_save);
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % find number of events emitted
    emit_indices = strfind(info.commands,'/LUXSim/beamOn ');
    num_evts_emitted_index = emit_indices(end)+15;
    num_evts_emitted = str2double(strtok(info.commands(num_evts_emitted_index:end),sprintf('\n')));
    
    sim_data.num_evts_emitted = sim_data.num_evts_emitted + ...
        num_evts_emitted;
    
    % get all events
    events = unique(record.event_num);
    
    fprintf('%d good events (%d records) found.\n', length(events), length(record.event_num));
    fprintf('Processing... ');
    
    % initialize universal data variables
    primary_E = zeros(length(events),1);
    primary_position = zeros(length(events),3);
    primary_direction = zeros(length(events),3);
    if save_primary_names
        primary_name = {1,length(events)};
    end
    primary_time = zeros(length(events),1);
    E_dep = zeros(length(events),1);
    r = zeros(length(events),1);
    x = zeros(length(events),1);
    y = zeros(length(events),1);
    z = zeros(length(events),1);
    t = zeros(length(events),1);
    sigma_r = zeros(length(events),1);
    sigma_x = zeros(length(events),1);
    sigma_y = zeros(length(events),1);
    sigma_z = zeros(length(events),1);
    sigma_t = zeros(length(events),1);
    
    % initialize non-universal data variables
    if ~ER_only
        E_dep_NR = zeros(length(events),1);
        E_dep_ER = zeros(length(events),1);
        r_NR = zeros(length(events),1);
        x_NR = zeros(length(events),1);
        y_NR = zeros(length(events),1);
        z_NR = zeros(length(events),1);
        t_NR = zeros(length(events),1);
        r_ER = zeros(length(events),1);
        x_ER = zeros(length(events),1);
        y_ER = zeros(length(events),1);
        z_ER = zeros(length(events),1);
        t_ER = zeros(length(events),1);
        sigma_r_NR = zeros(length(events),1);
        sigma_x_NR = zeros(length(events),1);
        sigma_y_NR = zeros(length(events),1);
        sigma_z_NR = zeros(length(events),1);
        sigma_t_NR = zeros(length(events),1);
        sigma_r_ER = zeros(length(events),1);
        sigma_x_ER = zeros(length(events),1);
        sigma_y_ER = zeros(length(events),1);
        sigma_z_ER = zeros(length(events),1);
        sigma_t_ER = zeros(length(events),1);
    end
    
    event_num_all = record.event_num;
    
    % parse over all events
    for ii_evt=1:length(events)
        
        rcd_evt_ind = find(event_num_all == events(ii_evt));
        
        primary_E(ii_evt) = record.primary_energy(rcd_evt_ind(1));
        primary_time(ii_evt) = record.primary_time(rcd_evt_ind(1));
        primary_position(ii_evt,:) = record.primary_position(rcd_evt_ind(1),:);
        primary_direction(ii_evt,:) = record.primary_direction(rcd_evt_ind(1),:);
        if save_primary_names
            primary_name{ii_evt} = record.primary_name{rcd_evt_ind(1)};
        end
        
        % parse over all records in this event
        for ii_rcd=1:length(rcd_evt_ind)
            
            % add component ID if necessary
            if ~any(record.volume_id(rcd_evt_ind(ii_rcd)) == sim_info.component_IDs)
                sim_info.component_IDs(end+1) = record.volume_id(rcd_evt_ind(ii_rcd));
                
                % add component name
                name_index = strfind(info.detector_components, ...
                    sprintf('ID %d: ',record.volume_id(rcd_evt_ind(ii_rcd))));
                [tok,rem] = strtok(info.detector_components(name_index:end),':');
                [tok,rem] = strtok(rem);
                [tok,rem] = strtok(rem);
                sim_info.component_names = [sim_info.component_names tok];
            end
            
            % get column to add entry to
            e_dep_col = find(sim_info.component_IDs == record.volume_id(rcd_evt_ind(ii_rcd)));
            
            % get hits
            hits_ind = record.record_hits_ind(rcd_evt_ind(ii_rcd)) + ...
                (0:(record.hits_size(rcd_evt_ind(ii_rcd))-1));
            
            % factor in time cut
            time_min = min(record.step_time(hits_ind));
            time_cut = (record.step_time(hits_ind) - time_min) < sim_info.time_window_ns;
            %hits = hits([hits.step_time] - time_min < sim_info.time_window);
            
            % cut on NR/ER events
            particle_id = record.particle_id(hits_ind);
            cut_NR = (particle_id > 10000 | particle_id == 2212)    & time_cut;
            cut_ER = (particle_id == 11 | particle_id == 22)        & time_cut;
            
            % get energy depositions
            E_dep(ii_evt,e_dep_col) = record.total_energy_deposition(rcd_evt_ind(ii_rcd));
            if ~ER_only
                E_dep_NR(ii_evt,e_dep_col) = sum(record.energy_deposition(hits_ind(cut_NR)));
                E_dep_ER(ii_evt,e_dep_col) = sum(record.energy_deposition(hits_ind(cut_ER)));
            end
            
            %%% find (energy-weighted) event position (NR events)
            if ~ER_only
                % define for convenience
                pos = record.position(hits_ind(cut_NR),:)';
                xpos = pos(1,:);
                ypos = pos(2,:);
                zpos = pos(3,:);
                E_dep_evt = record.energy_deposition(hits_ind(cut_NR));
                E_dep_sum = sum(E_dep_evt);
                time = record.step_time(hits_ind(cut_NR));

                if sum(cut_NR) > 1
                    x_NR(ii_evt,e_dep_col) = sum(xpos .* E_dep_evt) / E_dep_sum;
                    y_NR(ii_evt,e_dep_col) = sum(ypos .* E_dep_evt) / E_dep_sum;
                    z_NR(ii_evt,e_dep_col) = sum(zpos .* E_dep_evt) / E_dep_sum;
                    r_NR(ii_evt,e_dep_col) = sqrt( x_NR(ii_evt,e_dep_col)^2 + y_NR(ii_evt,e_dep_col)^2 );
                    t_NR(ii_evt,e_dep_col) = sum(time .* E_dep_evt) / E_dep_sum;

                    sigma_r_NR(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((xpos-x_NR(ii_evt,e_dep_col)).^2 + (ypos-y_NR(ii_evt,e_dep_col)).^2) ) );
                    sigma_x_NR(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((xpos-x_NR(ii_evt,e_dep_col)).^2) ) );
                    sigma_y_NR(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((ypos-y_NR(ii_evt,e_dep_col)).^2) ) );
                    sigma_z_NR(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((zpos-z_NR(ii_evt,e_dep_col)).^2) ) );
                    sigma_t_NR(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((time-t_NR(ii_evt,e_dep_col)).^2) ) );
                elseif sum(cut_NR) == 1
                    x_NR(ii_evt,e_dep_col) = xpos;
                    y_NR(ii_evt,e_dep_col) = ypos;
                    z_NR(ii_evt,e_dep_col) = zpos;
                    r_NR(ii_evt,e_dep_col) = sqrt( xpos^2 + ypos^2 );
                    t_NR(ii_evt,e_dep_col) = time;
                    sigma_r_NR(ii_evt,e_dep_col) = 0;
                    sigma_x_NR(ii_evt,e_dep_col) = 0;
                    sigma_y_NR(ii_evt,e_dep_col) = 0;
                    sigma_z_NR(ii_evt,e_dep_col) = 0;
                    sigma_t_NR(ii_evt,e_dep_col) = 0;
                else
                    x_NR(ii_evt,e_dep_col) = 0;
                    y_NR(ii_evt,e_dep_col) = 0;
                    z_NR(ii_evt,e_dep_col) = 0;
                    r_NR(ii_evt,e_dep_col) = 0;
                    t_NR(ii_evt,e_dep_col) = 0;
                    sigma_r_NR(ii_evt,e_dep_col) = 0;
                    sigma_x_NR(ii_evt,e_dep_col) = 0;
                    sigma_y_NR(ii_evt,e_dep_col) = 0;
                    sigma_z_NR(ii_evt,e_dep_col) = 0;
                    sigma_t_NR(ii_evt,e_dep_col) = 0;
                end

                %%% find (energy-weighted) event position (ER events)

                % (re)define for convenience
                pos = record.position(hits_ind(cut_ER),:)';
                xpos = pos(1,:);
                ypos = pos(2,:);
                zpos = pos(3,:);
                E_dep_evt = record.energy_deposition(hits_ind(cut_ER));
                E_dep_sum = sum(E_dep_evt);
                time = record.step_time(hits_ind(cut_ER));

                if sum(cut_ER) > 1
                    x_ER(ii_evt,e_dep_col) = sum(xpos .* E_dep_evt) / E_dep_sum;
                    y_ER(ii_evt,e_dep_col) = sum(ypos .* E_dep_evt) / E_dep_sum;
                    z_ER(ii_evt,e_dep_col) = sum(zpos .* E_dep_evt) / E_dep_sum;
                    r_ER(ii_evt,e_dep_col) = sqrt( x_ER(ii_evt,e_dep_col)^2 + y_ER(ii_evt,e_dep_col)^2 );
                    t_ER(ii_evt,e_dep_col) = sum(time .* E_dep_evt) / E_dep_sum;

                    sigma_r_ER(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((xpos-x_ER(ii_evt,e_dep_col)).^2 + (ypos-y_ER(ii_evt,e_dep_col)).^2) ) );
                    sigma_x_ER(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((xpos-x_ER(ii_evt,e_dep_col)).^2) ) );
                    sigma_y_ER(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((ypos-y_ER(ii_evt,e_dep_col)).^2) ) );
                    sigma_z_ER(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((zpos-z_ER(ii_evt,e_dep_col)).^2) ) );
                    sigma_t_ER(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                        sum( E_dep_evt .* ((time-t_ER(ii_evt,e_dep_col)).^2) ) );
                elseif sum(cut_ER) == 1
                    x_ER(ii_evt,e_dep_col) = xpos;
                    y_ER(ii_evt,e_dep_col) = ypos;
                    z_ER(ii_evt,e_dep_col) = zpos;
                    r_ER(ii_evt,e_dep_col) = sqrt( xpos^2 + ypos^2 );
                    t_ER(ii_evt,e_dep_col) = time;
                    sigma_r_ER(ii_evt,e_dep_col) = 0;
                    sigma_x_ER(ii_evt,e_dep_col) = 0;
                    sigma_y_ER(ii_evt,e_dep_col) = 0;
                    sigma_z_ER(ii_evt,e_dep_col) = 0;
                    sigma_t_ER(ii_evt,e_dep_col) = 0;
                else
                    x_ER(ii_evt,e_dep_col) = 0;
                    y_ER(ii_evt,e_dep_col) = 0;
                    z_ER(ii_evt,e_dep_col) = 0;
                    r_ER(ii_evt,e_dep_col) = 0;
                    t_ER(ii_evt,e_dep_col) = 0;
                    sigma_r_ER(ii_evt,e_dep_col) = 0;
                    sigma_x_ER(ii_evt,e_dep_col) = 0;
                    sigma_y_ER(ii_evt,e_dep_col) = 0;
                    sigma_z_ER(ii_evt,e_dep_col) = 0;
                    sigma_t_ER(ii_evt,e_dep_col) = 0;
                end
            end
                        
            %%% find (energy-weighted) event position (ALL events)
            
            % (re)define for convenience
            
            pos = record.position(hits_ind(cut_ER | cut_NR),:)';
            xpos = pos(1,:);
            ypos = pos(2,:);
            zpos = pos(3,:);
            E_dep_evt = record.energy_deposition(hits_ind(cut_ER | cut_NR));
            E_dep_sum = sum(E_dep_evt);
            time = record.step_time(hits_ind(cut_ER | cut_NR));
            
            if sum(cut_NR | cut_ER) > 1
                x(ii_evt,e_dep_col) = sum(xpos .* E_dep_evt) / E_dep_sum;
                y(ii_evt,e_dep_col) = sum(ypos .* E_dep_evt) / E_dep_sum;
                z(ii_evt,e_dep_col) = sum(zpos .* E_dep_evt) / E_dep_sum;
                r(ii_evt,e_dep_col) = sqrt( x(ii_evt,e_dep_col)^2 + y(ii_evt,e_dep_col)^2 );
                t(ii_evt,e_dep_col) = sum(time .* E_dep_evt) / E_dep_sum;
                
                sigma_r(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                    sum( E_dep_evt .* ((xpos-x(ii_evt,e_dep_col)).^2 + (ypos-y(ii_evt,e_dep_col)).^2) ) );
                sigma_x(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                    sum( E_dep_evt .* ((xpos-x(ii_evt,e_dep_col)).^2) ) );
                sigma_y(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                    sum( E_dep_evt .* ((ypos-y(ii_evt,e_dep_col)).^2) ) );
                sigma_z(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                    sum( E_dep_evt .* ((zpos-z(ii_evt,e_dep_col)).^2) ) );
                sigma_t(ii_evt,e_dep_col) = sqrt( (E_dep_sum/(E_dep_sum^2 - sum(E_dep_evt.^2))) * ...
                    sum( E_dep_evt .* ((time-t(ii_evt,e_dep_col)).^2) ) );
            elseif sum(cut_NR | cut_ER) == 1
                x(ii_evt,e_dep_col) = xpos;
                y(ii_evt,e_dep_col) = ypos;
                z(ii_evt,e_dep_col) = zpos;
                r(ii_evt,e_dep_col) = sqrt( xpos^2 + ypos^2 );
                t(ii_evt,e_dep_col) = time;
                sigma_r(ii_evt,e_dep_col) = 0;
                sigma_x(ii_evt,e_dep_col) = 0;
                sigma_y(ii_evt,e_dep_col) = 0;
                sigma_z(ii_evt,e_dep_col) = 0;
                sigma_t(ii_evt,e_dep_col) = 0;
            else
                x(ii_evt,e_dep_col) = 0;
                y(ii_evt,e_dep_col) = 0;
                z(ii_evt,e_dep_col) = 0;
                r(ii_evt,e_dep_col) = 0;
                t(ii_evt,e_dep_col) = 0;
                sigma_r(ii_evt,e_dep_col) = 0;
                sigma_x(ii_evt,e_dep_col) = 0;
                sigma_y(ii_evt,e_dep_col) = 0;
                sigma_z(ii_evt,e_dep_col) = 0;
                sigma_t(ii_evt,e_dep_col) = 0;
            end
            
            
            clear pos xpos ypos zpos time E_dep_evt
            
        end
        
    end
    
    clear record info
    
    % add universal records to sim_data
    sim_data.primary_E(end+1:end+length(primary_E),1) = primary_E;
    sim_data.primary_time(end+1:end+length(primary_time),1) = primary_time;
    sim_data.primary_position(end+1:end+size(primary_position,1),:) = primary_position;
    sim_data.primary_direction(end+1:end+size(primary_direction,1),:) = primary_direction;
    if save_primary_names
        sim_data.primary_name = primary_name;
    end
    sim_data.E_dep(end+1:end+size(E_dep,1),1:size(E_dep,2)) = E_dep;
    sim_data.r(end+1:end+size(r,1),1:size(r,2)) = r;
    sim_data.x(end+1:end+size(x,1),1:size(x,2)) = x;
    sim_data.y(end+1:end+size(y,1),1:size(y,2)) = y;
    sim_data.z(end+1:end+size(z,1),1:size(z,2)) = z;
    sim_data.t(end+1:end+size(t,1),1:size(t,2)) = t;
    sim_data.sigma_r(end+1:end+size(sigma_r,1),1:size(sigma_r,2)) = sigma_r;
    sim_data.sigma_x(end+1:end+size(sigma_x,1),1:size(sigma_x,2)) = sigma_x;
    sim_data.sigma_y(end+1:end+size(sigma_y,1),1:size(sigma_y,2)) = sigma_y;
    sim_data.sigma_z(end+1:end+size(sigma_z,1),1:size(sigma_z,2)) = sigma_z;
    sim_data.sigma_t(end+1:end+size(sigma_t,1),1:size(sigma_t,2)) = sigma_t;
    
    % add non-universal records to sim_data
    if ~ER_only
        sim_data.E_dep_NR(end+1:end+size(E_dep_NR,1),1:size(E_dep_NR,2)) = E_dep_NR;
        sim_data.E_dep_ER(end+1:end+size(E_dep_ER,1),1:size(E_dep_NR,2)) = E_dep_ER;
        sim_data.r_NR(end+1:end+size(r_NR,1),1:size(r_NR,2)) = r_NR;
        sim_data.x_NR(end+1:end+size(x_NR,1),1:size(x_NR,2)) = x_NR;
        sim_data.y_NR(end+1:end+size(y_NR,1),1:size(y_NR,2)) = y_NR;
        sim_data.z_NR(end+1:end+size(z_NR,1),1:size(z_NR,2)) = z_NR;
        sim_data.t_NR(end+1:end+size(t_NR,1),1:size(t_NR,2)) = t_NR;
        sim_data.r_ER(end+1:end+size(r_ER,1),1:size(r_ER,2)) = r_ER;
        sim_data.x_ER(end+1:end+size(x_ER,1),1:size(x_ER,2)) = x_ER;
        sim_data.y_ER(end+1:end+size(y_ER,1),1:size(y_ER,2)) = y_ER;
        sim_data.z_ER(end+1:end+size(z_ER,1),1:size(z_ER,2)) = z_ER;
        sim_data.t_ER(end+1:end+size(t_ER,1),1:size(t_ER,2)) = t_ER;
        sim_data.sigma_r_NR(end+1:end+size(sigma_r_NR,1),1:size(sigma_r_NR,2)) = sigma_r_NR;
        sim_data.sigma_x_NR(end+1:end+size(sigma_x_NR,1),1:size(sigma_x_NR,2)) = sigma_x_NR;
        sim_data.sigma_y_NR(end+1:end+size(sigma_y_NR,1),1:size(sigma_y_NR,2)) = sigma_y_NR;
        sim_data.sigma_z_NR(end+1:end+size(sigma_z_NR,1),1:size(sigma_z_NR,2)) = sigma_z_NR;
        sim_data.sigma_t_NR(end+1:end+size(sigma_t_NR,1),1:size(sigma_t_NR,2)) = sigma_t_NR;
        sim_data.sigma_r_ER(end+1:end+size(sigma_r_ER,1),1:size(sigma_r_ER,2)) = sigma_r_ER;
        sim_data.sigma_x_ER(end+1:end+size(sigma_x_ER,1),1:size(sigma_x_ER,2)) = sigma_x_ER;
        sim_data.sigma_y_ER(end+1:end+size(sigma_y_ER,1),1:size(sigma_y_ER,2)) = sigma_y_ER;
        sim_data.sigma_z_ER(end+1:end+size(sigma_z_ER,1),1:size(sigma_z_ER,2)) = sigma_z_ER;
        sim_data.sigma_t_ER(end+1:end+size(sigma_t_ER,1),1:size(sigma_t_ER,2)) = sigma_t_ER;
    end
    
    num_evts = num_evts + length(primary_E);
    
    clear primary_E primary_position primary_direction E_dep E_dep_NR E_dep_ER r_NR x_NR y_NR z_NR t_NR...
        r_ER x_ER y_ER z_ER t_ER r x y z t sigma_r_NR sigma_x_NR sigma_y_NR sigma_z_NR sigma_t_NR ...
        sigma_r_ER sigma_x_ER sigma_y_ER sigma_z_ER sigma_t_ER sigma_r sigma_x sigma_y sigma_z sigma_t
    
    t = toc;
    fprintf('done (%3.2f s)\n', t);
    
    % Write the mat file
    % Old scheme keeps the random seed number at the end
    %save_filename = [output_dir filesep files_to_load{ii_file}(1:end-4) '_lab.mat'];
    % this new scheme removes the random numbers at the end of the bin file and adds a serial number instead 
    save_filename = [output_dir filesep strtok(files_to_load{ii_file},'.') '_' sprintf('%03d',ii_file) '_lab.mat'];
    % Same thing but without the serial number appended
    %save_filename = [output_dir filesep strtok(files_to_load{ii_file},'.') '_lab.mat'];
    save(save_filename, 'sim_info', 'sim_data', '-v7.3');
    fprintf('\nOutput saved to %s\n', save_filename);

    if ii_file < length(files_to_load)
        fprintf('Continuing...\n');
    end
    
function_end_time = clock;
    
end



%% Epilogue

fprintf('\n\t*** All files processed ***\n\n');
fprintf('All files processed (%1.0f s)\n\n', etime(function_end_time, function_start_time));

end


%% Functions

function [sim_data,sim_info] = InitializeDataStructures(ER_only,time_window_ns)
    % Info fields
    sim_info.component_IDs = [];
    sim_info.component_names = {};
    sim_info.time_window_ns = time_window_ns;

    % Universal data fields
    sim_data.num_evts_emitted = 0;
    sim_data.primary_E = [];
    sim_data.primary_time = [];
    sim_data.primary_position = [];
    sim_data.primary_direction = [];
    sim_data.primary_name = {};
    sim_data.E_dep = [];
    sim_data.r = [];
    sim_data.x = [];
    sim_data.y = [];
    sim_data.z = [];
    sim_data.t = [];
    sim_data.sigma_r = [];
    sim_data.sigma_x = [];
    sim_data.sigma_y = [];
    sim_data.sigma_z = [];
    sim_data.sigma_t = [];

    % Non-universal data fields
    if ~ER_only
        sim_data.E_dep_NR = [];
        sim_data.E_dep_ER = [];
        sim_data.r_NR = [];
        sim_data.x_NR = [];
        sim_data.y_NR = [];
        sim_data.z_NR = [];
        sim_data.t_NR = [];
        sim_data.r_ER = [];
        sim_data.x_ER = [];
        sim_data.y_ER = [];
        sim_data.z_ER = [];
        sim_data.t_ER = [];
        sim_data.sigma_r_NR = [];
        sim_data.sigma_x_NR = [];
        sim_data.sigma_y_NR = [];
        sim_data.sigma_z_NR = [];
        sim_data.sigma_t_NR = [];
        sim_data.sigma_r_ER = [];
        sim_data.sigma_x_ER = [];
        sim_data.sigma_y_ER = [];
        sim_data.sigma_z_ER = [];
        sim_data.sigma_t_ER = [];
    end
end

%%
function [record,info] = LoadWithoutMEX(file,save_hit_names,save_primary_names)

try
    
    tic;
    
    % open file
    fid = fopen(file);
    
    % error check
    if fid < 0
        % try tacking on a .bin suffix and reloading
        fid = fopen([file '.bin']);
        
        if fid < 0 % if still failing, give up
            fprintf('WARNING: unable to find file %s in directory %s\n',...
                filename,file_directory);
            disp('Moving on...');
            return
        else % correct filename and keep going
            filename = [filename '.bin'];
        end
    end
    
    % find binary file total size
    file_tmp = dir(file);
    filesize_bytes = file_tmp(1).bytes;
    
    if filesize_bytes == 0
        fprintf('WARNING: file %s is empty\n', file);
        disp('Moving on...');
        return
    end
    
    %%% Preamble
    
    % read number of records
    record_length = fread(fid,1,'int');
    
    % read production time
    production_time_length = fread(fid,1,'int');
    info.production_time = fread(fid,production_time_length,'*char')';
    
    % read Geant4 version
    geant4_version_length = fread(fid,1,'int');
    info.geant4_version = fread(fid,geant4_version_length,'*char')';
    
    % read revision number
    revision_number_length = fread(fid,1,'int');
    info.revision_number = fread(fid,revision_number_length,'*char')';
    
    % read computer name
    computer_name_length = fread(fid,1,'int');
    info.computer_name = fread(fid,computer_name_length,'*char')';
    
    %%% First-time run stuff
    if ~feof(fid)
        % read commands
        commands_length = fread(fid,1,'int');
        info.commands = fread(fid,commands_length,'*char')';
        
        % read differences
        svn_diff_length = fread(fid,1,'int');
        info.svn_diff = fread(fid,svn_diff_length,'*char')';
        
        % read detector components
        det_comp_length = fread(fid,1,'int');
        info.detector_components = fread(fid,det_comp_length,'*char')';
    end
    
    info.filename = file;
    
    
    %%% Particle records
    
    total_loaded_bytes = 28+...
        production_time_length+...
        geant4_version_length+...
        revision_number_length+...
        computer_name_length+...
        commands_length+...
        svn_diff_length+...
        det_comp_length;
    %record_counter = 1;
    pri_counter = 1;
    step_counter = 1;
    
    
    record_level = zeros(1,record_length);
    opticalphoton_record_level = zeros(1,record_length);
    thermalelectron_record_level = zeros(1,record_length);
    volume_id = zeros(1,record_length);
    event_num = zeros(1,record_length);
    total_energy_deposition = zeros(1,record_length);
    num_opticalphotons = zeros(1,record_length);
    num_thermalelectrons = zeros(1,record_length);
    hits_size = zeros(1,record_length);
    record_hits_ind = zeros(1,record_length);
    
    mult_p = 10;
    primary_name = {};
    if save_primary_names
		primary_name = cell(1,record_length*mult_p);
	end
    primary_energy = zeros(1,record_length*mult_p);
    primary_time = zeros(1,record_length*mult_p);
    primary_position = zeros(record_length*mult_p,3);
    primary_direction = zeros(record_length*mult_p,3);
    primary_event_num = zeros(1,record_length*mult_p);
    
    mult = 1000;
    particle_name = {};
    creator_process_name = {};
    step_process_name = {};
    if save_hit_names
		particle_name = cell(1,record_length*mult);
		creator_process_name = cell(1,record_length*mult);
        step_process_name = cell(1,record_length*mult);
	end
    step_num = zeros(1,record_length*mult);
    particle_id = zeros(1,record_length*mult);
    track_id = zeros(1,record_length*mult);
    parent_id = zeros(1,record_length*mult);
    particle_energy = zeros(1,record_length*mult);
    particle_direction = zeros(record_length*mult,3);
    energy_deposition = zeros(1,record_length*mult);
    position = zeros(record_length*mult,3);
    step_time = zeros(1,record_length*mult);
    
    % particle_name = {};
    % step_num = [];
    % particle_id = [];
    % track_id = [];
    % parent_id = [];
    % particle_energy = [];
    % particle_direction = [];
    % energy_deposition = [];
    % position = [];
    % step_time = [];
    
    update_time = 5; %s
    for record_counter=1:record_length
        time = toc;
        if time > update_time
            fprintf('%d%% loaded (%d evts / %d steps)\n',...
                floor(record_counter / record_length * 100), ...
                record_counter, step_counter);
            tic;
        end
        
        %%% primary particle info
        % primary particle size
        primary_size = fread(fid,1,'int');

        %primary_name = [primary_name cell(1,primary_size)];
        %primary_energy = [primary_energy zeros(1,primary_size)];
        %primary_position = [primary_position; zeros(primary_size,3)];
        %primary_direction = [primary_direction; zeros(primary_size,3)];
        
        pri_counter_save = pri_counter;
        pri_counter_evt = pri_counter;
        for ii_pri=1:primary_size
            % primary particle name
            primary_name_length = fread(fid,1,'int');
            name_tmp = fread(fid,primary_name_length,'*char')';
            if save_primary_names
				primary_name{pri_counter} = name_tmp;
			end
            % primary particle energy
            primary_energy(pri_counter) = fread(fid,1,'double');
            % primary particle time
            primary_time(pri_counter) = fread(fid,1,'double');
            % primary particle position
            primary_position(pri_counter,1:3) = ...
                fread(fid,3,'double');
            % primary particle direction
            primary_direction(pri_counter,1:3) = ...
                fread(fid,3,'double');
            
            pri_counter = pri_counter+1;
        end
        
        %%% record size-independent entries
        % record level
        record_level(record_counter) = fread(fid,1,'int');
        % optical photon record level
        opticalphoton_record_level(record_counter) = fread(fid,1,'int');
        % thermalElectron record level
        thermalelectron_record_level(record_counter) = fread(fid,1,'int');
        % volume ID
        volume_id(record_counter) = fread(fid,1,'int');
        % Event #
        event_num(record_counter) = fread(fid,1,'int');
        % set the event number for each primary in this event
        primary_event_num(pri_counter_evt:(pri_counter-1)) = ...
            event_num(record_counter);
        % Energy deposition
        if record_level(record_counter) > 0
            total_energy_deposition(record_counter) = fread(fid,1,'double');
        end
        % Number of optical photons
        if opticalphoton_record_level(record_counter) > 0
            num_opticalphotons(record_counter) = fread(fid,1,'int');
        end
        % Number of thermal electrons
        if thermalelectron_record_level(record_counter) > 0
            num_thermalelectrons(record_counter) = fread(fid,1,'int');
        end
        % Record size
        hts_sz = fread(fid,1,'int');
        hits_size(record_counter) = hts_sz;
        
        record_hits_ind(record_counter) = step_counter;
        
        % update total bytes loaded
        total_loaded_bytes = total_loaded_bytes + 24;
        
        if hits_size(record_counter) > 0
            % preallocate memory
            %particle_name = [particle_name cell(1,hts_sz)];
            %creator_process_name = [creator_process_name cell(1,hts_sz)];
            %step_process_name = [step_process_name cell(1,hts_sz)];
            %step_num = [step_num zeros(1,hts_sz)];
            %particle_id = [particle_id zeros(1,hts_sz)];
            %track_id = [track_id zeros(1,hts_sz)];
            %parent_id = [parent_id zeros(1,hts_sz)];
            %particle_energy = [particle_energy zeros(1,hts_sz)];
            %particle_direction = [particle_direction; zeros(hts_sz,3)];
            %energy_deposition = [energy_deposition zeros(1,hts_sz)];
            %position = [position; zeros(hts_sz,3)];
            %step_time = [step_time zeros(1,hts_sz)];
            
            % read per-step variables in from file
            for ii_step=1:hits_size(record_counter)
            	% read particle name
                particle_name_length = fread(fid,1,'int');
                name = fread(fid,particle_name_length,'*char')';
                if save_hit_names
					particle_name{step_counter} = name;
				end
				% read creator process name
                creator_process_name_length = fread(fid,1,'int');
                name = fread(fid,creator_process_name_length,'*char')';
                if save_hit_names
					creator_process_name{step_counter} = name;
                end
                % read step process name
                step_process_name_length = fread(fid,1,'int');
                name = fread(fid,step_process_name_length,'*char')';
                if save_hit_names
                	step_process_name{step_counter} = name;
                end
                % read step number
                step_num(step_counter) = fread(fid,1,'int');
                % read particle ID
                particle_id(step_counter) = fread(fid,1,'int');
                % read track ID
                track_id(step_counter) = fread(fid,1,'int');
                % read parent ID
                parent_id(step_counter) = fread(fid,1,'int');
                % read particle energy
                particle_energy(step_counter) = fread(fid,1,'double');
                % read particle direction
                particle_direction(step_counter,1:3) = fread(fid,3,'double');
                % read energy deposition
                energy_deposition(step_counter) = fread(fid,1,'double');
                % read particle position
                position(step_counter,1:3) = fread(fid,3,'double');
                % read step time
                step_time(step_counter) = fread(fid,1,'double');
                
                step_counter = step_counter+1;
            end
            
        end
    end
    
    fclose(fid);
    
    fprintf('100%% loaded (%d evts / %d steps)\n', ...
        record_counter, step_counter);
    
    if save_primary_names
		primary_name = primary_name(1:pri_counter-1);
	end
    primary_energy = primary_energy(1:pri_counter-1);
    primary_time = primary_time(1:pri_counter-1);
    primary_position = primary_position(1:pri_counter-1,:);
    primary_direction = primary_direction(1:pri_counter-1,:);
    primary_event_num = primary_event_num(1:pri_counter-1);
    
    if save_hit_names
		particle_name = particle_name(1:step_counter-1);
		creator_process_name = creator_process_name(1:step_counter-1);
        step_process_name = step_process_name(1:step_counter-1);
	end
    step_num = step_num(1:step_counter-1);
    particle_id = particle_id(1:step_counter-1);
    track_id = track_id(1:step_counter-1);
    parent_id = parent_id(1:step_counter-1);
    particle_energy = particle_energy(1:step_counter-1);
    particle_direction = particle_direction(1:step_counter-1,:);
    energy_deposition = energy_deposition(1:step_counter-1);
    position = position(1:step_counter-1,:);
    step_time = step_time(1:step_counter-1);
    
    % %%%%%%%%%%%%%%%%%%%%%%%% Assign variables %%%%%%%%%%%%%%%%%%%%%%%% %
    
    record.record_level = record_level;
    record.opticalphoton_record_level = opticalphoton_record_level;
    record.thermalelectron_record_level = thermalelectron_record_level;
    record.volume_id = volume_id;
    record.event_num = event_num;
    record.total_energy_deposition = total_energy_deposition;
    record.num_opticalphotons = num_opticalphotons;
    record.num_thermalelectrons = num_thermalelectrons;
    record.hits_size = hits_size;
    record.record_hits_ind = record_hits_ind;
    
    if save_primary_names
        record.primary_name = primary_name;
    end
    record.primary_energy = primary_energy;
    record.primary_time = primary_time;
    record.primary_position = primary_position;
    record.primary_direction = primary_direction;
    record.primary_event_num = primary_event_num;
    
    if save_hit_names
        record.particle_name = particle_name;
        record.creator_process_name = creator_process_name;
        record.step_process_name = step_process_name;
    end
    record.step_num = step_num;
    record.particle_id = particle_id;
    record.track_id = track_id;
    record.parent_id = parent_id;
    record.particle_energy = particle_energy;
    record.particle_direction = particle_direction;
    record.energy_deposition = energy_deposition;
    record.position = position;
    record.step_time = step_time;
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
catch
    
    fprintf('WARNING: error loading file %s\n', file);
    record = [];
    info = [];
    
end

end







